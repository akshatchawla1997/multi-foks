<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Face Capture with Virtual Try-On</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 30px;
        max-width: 700px;
        width: 100%;
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 28px;
      }

      .step-container {
        display: none;
      }

      .step-container.active {
        display: block;
      }

      .camera-container {
        position: relative;
        width: 100%;
        max-width: 640px;
        margin: 0 auto 20px;
        border-radius: 15px;
        overflow: hidden;
        background: #000;
      }

      #videoElement {
        width: 100%;
        height: auto;
        display: block;
        transform: scaleX(-1);
      }

      #captureCanvas {
        display: none;
      }

      #overlayCanvas {
        display: block;
        max-width: 100%;
        height: auto;
      }

      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      .face-guide-oval {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 260px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        transition: all 0.3s ease;
      }

      .face-guide-oval.aligned {
        border-color: #4caf50;
        border-width: 4px;
        box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
      }

      .face-guide-oval.detecting {
        border-color: #ffc107;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.5;
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.05);
        }
      }

      .alignment-status {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        text-align: center;
        min-width: 250px;
        font-weight: 600;
        letter-spacing: 0.5px;
        z-index: 10;
      }

      .alignment-status.aligned {
        background: linear-gradient(135deg, #4caf50, #66bb6a);
        animation: glow 0.5s ease;
      }

      .alignment-status.misaligned {
        background: linear-gradient(135deg, #f44336, #ef5350);
      }

      .alignment-status.capturing {
        background: linear-gradient(135deg, #2196f3, #42a5f5);
      }

      @keyframes glow {
        0% {
          box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        50% {
          box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }
        100% {
          box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
      }

      .progress-container {
        position: absolute;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        width: 80%;
        display: none;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 15px;
        z-index: 10;
      }

      .progress-container.active {
        display: block;
        animation: slideUp 0.3s ease;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .progress-bar {
        width: 100%;
        height: 10px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4caf50, #8bc34a, #cddc39);
        border-radius: 10px;
        width: 0%;
        transition: width 0.1s linear;
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
      }

      .progress-text {
        text-align: center;
        color: white;
        font-size: 13px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .countdown {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 72px;
        font-weight: bold;
        color: white;
        text-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        display: none;
        animation: countdownPulse 1s ease;
        z-index: 10;
      }

      @keyframes countdownPulse {
        0% {
          transform: translate(-50%, -50%) scale(1.5);
          opacity: 0;
        }
        50% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(0.9);
          opacity: 0.8;
        }
      }

      .result-container {
        text-align: center;
        animation: fadeIn 0.5s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .result-container img,
      .result-container canvas {
        max-width: 100%;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        margin-bottom: 20px;
        display: block;
        margin-left: auto;
        margin-right: auto;
      }

      .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }

      button {
        padding: 12px 30px;
        font-size: 16px;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .start-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }

      .start-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .retake-btn {
        background: linear-gradient(135deg, #f44336, #e91e63);
        color: white;
      }

      .download-btn {
        background: linear-gradient(135deg, #4caf50, #66bb6a);
        color: white;
      }

      .instructions {
        background: linear-gradient(135deg, #f5f5f5, #e8e8e8);
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        border-left: 4px solid #667eea;
      }

      .instructions h3 {
        color: #333;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .instructions ul {
        list-style: none;
        padding: 0;
      }

      .instructions li {
        padding: 8px 0;
        color: #555;
        position: relative;
        padding-left: 30px;
        line-height: 1.5;
      }

      .instructions li:before {
        content: "✓";
        position: absolute;
        left: 0;
        color: #4caf50;
        font-weight: bold;
        font-size: 18px;
      }

      .error-message {
        background: linear-gradient(135deg, #ff5252, #ff6b6b);
        color: white;
        padding: 15px;
        border-radius: 10px;
        margin-top: 20px;
        display: none;
        animation: shake 0.5s ease;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-10px);
        }
        75% {
          transform: translateX(10px);
        }
      }

      .frame-selector {
        display: flex;
        gap: 15px;
        margin: 20px 0;
        justify-content: center;
        flex-wrap: wrap;
      }

      .frame-option {
        width: 120px;
        padding: 10px;
        border: 3px solid transparent;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        text-align: center;
        background: #f5f5f5;
      }

      .frame-option:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .frame-option.selected {
        border-color: #667eea;
        background: rgba(102, 126, 234, 0.1);
      }

      .frame-preview {
        width: 100%;
        height: 40px;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 30px;
      }

      .adjustment-controls {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .slider-group {
        margin-bottom: 20px;
      }

      .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        font-weight: 600;
      }

      .slider-value {
        color: #667eea;
        font-weight: bold;
        background: rgba(102, 126, 234, 0.1);
        padding: 3px 10px;
        border-radius: 12px;
      }

      input[type="range"] {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #667eea;
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #667eea;
        cursor: pointer;
        border: none;
      }

      .measurements-panel {
        background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
        border-radius: 15px;
        padding: 20px;
        margin: 20px 0;
      }

      .measurement-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        background: white;
        border-radius: 10px;
        margin-bottom: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .measurement-label {
        font-weight: 600;
        color: #333;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }

      .measurement-value {
        font-size: 1.1em;
        font-weight: bold;
        color: #667eea;
        background: rgba(102, 126, 234, 0.1);
        padding: 5px 15px;
        border-radius: 20px;
      }

      .measurement-section {
        margin-bottom: 20px;
      }

      .measurement-section-title {
        font-weight: bold;
        color: #667eea;
        margin-bottom: 10px;
        font-size: 15px;
        padding-left: 12px;
      }

      @media (max-width: 768px) {
        body {
          padding: 0;
          align-items: flex-start;
        }

        .container {
          padding: 15px;
          border-radius: 0;
          max-width: 100%;
          min-height: 100vh;
          box-shadow: none;
        }

        h1 {
          font-size: 20px;
          margin-bottom: 15px;
        }

        .instructions {
          padding: 15px;
          margin-bottom: 15px;
        }

        .instructions h3 {
          font-size: 16px;
          margin-bottom: 10px;
        }

        .instructions li {
          font-size: 13px;
          padding: 6px 0;
          padding-left: 25px;
        }

        .camera-container {
          border-radius: 10px;
          margin-bottom: 15px;
        }

        .face-guide-oval {
          width: 160px;
          height: 220px;
        }

        .alignment-status {
          top: 10px;
          font-size: 12px;
          padding: 10px 20px;
          min-width: 200px;
          max-width: 90%;
        }

        .progress-container {
          bottom: 20px;
          width: 90%;
          padding: 12px;
        }

        .progress-text {
          font-size: 11px;
        }

        .countdown {
          font-size: 56px;
        }

        .controls {
          flex-direction: column;
          gap: 10px;
        }

        button {
          width: 100%;
          padding: 14px 20px;
          font-size: 14px;
        }

        .frame-selector {
          gap: 10px;
          margin: 15px 0;
        }

        .frame-option {
          width: 90px;
          padding: 8px;
        }

        .frame-preview {
          height: 35px;
          margin-bottom: 5px;
        }

        .frame-option div:last-child {
          font-size: 12px;
        }

        .adjustment-controls {
          padding: 15px;
          margin-top: 15px;
        }

        .slider-group {
          margin-bottom: 15px;
        }

        .slider-label {
          font-size: 13px;
          margin-bottom: 6px;
        }

        .slider-value {
          font-size: 13px;
          padding: 2px 8px;
        }

        .measurements-panel {
          padding: 15px;
          margin: 15px 0;
        }

        .measurements-panel h3 {
          font-size: 16px;
          margin: 0 0 10px 0;
        }

        .measurement-row {
          padding: 10px;
          margin-bottom: 8px;
        }

        .measurement-label {
          font-size: 13px;
        }

        .measurement-value {
          font-size: 1em;
          padding: 4px 12px;
        }

        .error-message {
          font-size: 13px;
          padding: 12px;
          margin-top: 15px;
        }

        h2 {
          font-size: 18px !important;
          margin-bottom: 15px !important;
        }

        .measurement-section-title {
          font-size: 13px;
        }
      }

      @media (max-width: 480px) {
        h1 {
          font-size: 18px;
        }

        .face-guide-oval {
          width: 140px;
          height: 200px;
        }

        .alignment-status {
          font-size: 11px;
          padding: 8px 16px;
        }

        .frame-option {
          width: 80px;
        }
      }

      @media (max-width: 768px) and (orientation: landscape) {
        .container {
          padding: 10px;
        }

        .instructions {
          padding: 10px;
          margin-bottom: 10px;
        }

        .instructions li {
          font-size: 12px;
          padding: 4px 0;
        }

        .face-guide-oval {
          width: 120px;
          height: 180px;
        }

        .camera-container {
          margin-bottom: 10px;
        }

        .controls {
          flex-direction: row;
          justify-content: center;
        }

        button {
          width: auto;
          padding: 10px 20px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>📸 Smart Face Capture & Virtual Try-On</h1>

      <div id="step1" class="step-container active">
        <div class="instructions">
          <h3>📋 Quick Instructions</h3>
          <ul>
            <li>Position your face within the oval guide</li>
            <li>Keep your head straight and centered</li>
            <li>Ensure good lighting on your face</li>
            <li>System will auto-capture when aligned</li>
            <li>Hold still during the capture countdown</li>
          </ul>
        </div>

        <div class="camera-container" id="cameraContainer">
          <video id="videoElement" autoplay muted playsinline></video>
          <canvas id="captureCanvas"></canvas>

          <div class="overlay">
            <div class="face-guide-oval" id="faceGuide"></div>

            <div class="alignment-status" id="alignmentStatus">
              Click "Start Camera" to begin
            </div>

            <div class="countdown" id="countdown"></div>

            <div class="progress-container" id="progressContainer">
              <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
              </div>
              <div class="progress-text" id="progressText">
                Hold Still - Capturing...
              </div>
            </div>
          </div>
        </div>

        <div class="controls">
          <button class="start-btn" id="startBtn" onclick="app.startCamera()">
            Start Camera
          </button>
        </div>

        <div class="error-message" id="errorMessage"></div>
      </div>

      <div id="step2" class="step-container">
        <h2 style="text-align: center; margin-bottom: 20px">
          🎯 Try Virtual Eyeglasses
        </h2>

        <div class="result-container" style="margin-bottom: 30px">
          <canvas id="overlayCanvas"></canvas>
        </div>

        <div class="frame-selector" id="frameSelector"></div>

        <div class="adjustment-controls">
          <div class="slider-group">
            <div class="slider-label">
              <span>↕️ Vertical Position</span>
              <span class="slider-value" id="verticalValue">0</span>
            </div>
            <input
              type="range"
              id="verticalSlider"
              min="-50"
              max="50"
              value="0"
            />
          </div>

          <div class="slider-group">
            <div class="slider-label">
              <span>📏 Frame Size</span>
              <span class="slider-value" id="sizeValue">100%</span>
            </div>
            <input
              type="range"
              id="sizeSlider"
              min="60"
              max="200"
              value="100"
            />
          </div>

          <div class="slider-group">
            <div class="slider-label">
              <span>🔄 Rotation</span>
              <span class="slider-value" id="rotationValue">0°</span>
            </div>
            <input
              type="range"
              id="rotationSlider"
              min="-10"
              max="10"
              value="0"
              step="0.5"
            />
          </div>

          <button
            onclick="app.resetAdjustments()"
            class="retake-btn"
            style="width: 100%; margin-top: 10px"
          >
            Reset Position
          </button>
        </div>

        <div class="measurements-panel">
          <h3 style="margin: 0 0 15px 0; color: #333">
            📏 Precise Face Measurements
          </h3>

          <div class="measurement-section">
            <div class="measurement-section-title">Pupillary Distance (PD)</div>
            <div class="measurement-row">
              <span class="measurement-label">👁️ Total PD</span>
              <span class="measurement-value" id="pdTotalMeasurement"
                >-- mm</span
              >
            </div>
            <div class="measurement-row">
              <span class="measurement-label">◀️ Left PD</span>
              <span class="measurement-value" id="pdLeftMeasurement"
                >-- mm</span
              >
            </div>
            <div class="measurement-row">
              <span class="measurement-label">▶️ Right PD</span>
              <span class="measurement-value" id="pdRightMeasurement"
                >-- mm</span
              >
            </div>
          </div>

          <div class="measurement-section">
            <div class="measurement-section-title">Nose-to-Eye Distances</div>
            <div class="measurement-row">
              <span class="measurement-label">👃 Left Nose Distance</span>
              <span class="measurement-value" id="leftNoseMeasurement"
                >-- mm</span
              >
            </div>
            <div class="measurement-row">
              <span class="measurement-label">👃 Right Nose Distance</span>
              <span class="measurement-value" id="rightNoseMeasurement"
                >-- mm</span
              >
            </div>
            <div class="measurement-row">
              <span class="measurement-label">👃 Total Nose Distance</span>
              <span class="measurement-value" id="totalNoseMeasurement"
                >-- mm</span
              >
            </div>
          </div>

          <div class="measurement-section">
            <div class="measurement-section-title">Frame Fitting</div>
            <div class="measurement-row">
              <span class="measurement-label">📐 Fitting Height</span>
              <span class="measurement-value" id="fittingHeightMeasurement"
                >-- mm</span
              >
            </div>
            <div class="measurement-row">
              <span class="measurement-label">↔️ Face Width</span>
              <span class="measurement-value" id="faceWidthMeasurement"
                >-- mm</span
              >
            </div>
            <div class="measurement-row">
              <span class="measurement-label">↕️ Face Height</span>
              <span class="measurement-value" id="faceHeightMeasurement"
                >-- mm</span
              >
            </div>
          </div>

          <div class="measurement-section">
            <div class="measurement-section-title">Face Analysis</div>
            <div class="measurement-row">
              <span class="measurement-label">📊 Face Shape Ratio</span>
              <span class="measurement-value" id="faceRatioMeasurement"
                >--</span
              >
            </div>
            <div class="measurement-row">
              <span class="measurement-label">🎭 Face Shape</span>
              <span class="measurement-value" id="faceShapeMeasurement"
                >--</span
              >
            </div>
          </div>
        </div>

        <div class="controls">
          <button class="download-btn" onclick="app.downloadImage()">
            Download Image
          </button>
          <button class="retake-btn" onclick="app.retake()">
            Retake Photo
          </button>
        </div>
      </div>
    </div>

    <script>
      class FaceCaptureApp {
        constructor() {
          this.video = document.getElementById("videoElement");
          this.captureCanvas = document.getElementById("captureCanvas");
          this.captureCtx = this.captureCanvas.getContext("2d");
          this.overlayCanvas = document.getElementById("overlayCanvas");
          this.overlayCtx = this.overlayCanvas.getContext("2d");

          this.stream = null;
          this.isCapturing = false;
          this.detectionInterval = null;
          this.alignmentCounter = 0;
          this.requiredAlignmentFrames = 15;
          this.captureDelayMs = 3000;
          this.previousFrame = null;
          this.motionThreshold = 30;

          this.capturedPhoto = null;
          this.landmarks = null;
          this.faceMesh = null;

          this.measurements = {
            pdTotal: 0,
            pdLeft: 0,
            pdRight: 0,
            leftNose: 0,
            rightNose: 0,
            noseTotal: 0,
            fittingHeight: 0,
            faceWidth: 0,
            faceHeight: 0,
            faceRatio: 0,
            pixelsPerMM: 0,
          };

          this.frameAdjustments = { vertical: 0, size: 100, rotation: 0 };
          this.selectedFrameIndex = 0;

          this.frames = [
            {
              id: "frame1",
              name: "Frame 1",
              src: "frame1.png",
              widthMM: 124,
              heightMM: 41,
            },
            {
              id: "frame2",
              name: "Frame 2",
              src: "frame2.png",
              widthMM: 120,
              heightMM: 39,
            },
            {
              id: "frame3",
              name: "Frame 3",
              src: "frame3.png",
              widthMM: 118,
              heightMM: 42,
            },
          ];

          this.frameImages = {};
          this.loadFrameImages();
          this.setupEventListeners();
        }

        loadFrameImages() {
          this.frames.forEach((frame) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
              this.frameImages[frame.id] = img;
              console.log(`Loaded ${frame.name}`);
            };
            img.onerror = () => {
              console.error(`Failed to load ${frame.src}`);
            };
            img.src = frame.src;
          });
        }

        setupEventListeners() {
          document
            .getElementById("verticalSlider")
            .addEventListener("input", (e) => {
              this.frameAdjustments.vertical = parseInt(e.target.value);
              document.getElementById("verticalValue").textContent =
                e.target.value;
              this.updateOverlay();
              this.updateDynamicMeasurements();
            });

          document
            .getElementById("sizeSlider")
            .addEventListener("input", (e) => {
              this.frameAdjustments.size = parseInt(e.target.value);
              document.getElementById("sizeValue").textContent =
                e.target.value + "%";
              this.updateOverlay();
              this.recalculateAllMeasurements();
            });

          document
            .getElementById("rotationSlider")
            .addEventListener("input", (e) => {
              this.frameAdjustments.rotation = parseFloat(e.target.value);
              document.getElementById("rotationValue").textContent =
                e.target.value + "°";
              this.updateOverlay();
            });
        }

        async startCamera() {
          try {
            document.getElementById("errorMessage").style.display = "none";
            document.getElementById("startBtn").style.display = "none";

            this.stream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                facingMode: "user",
              },
              audio: false,
            });

            this.video.srcObject = this.stream;

            this.video.onloadedmetadata = () => {
              this.captureCanvas.width = this.video.videoWidth;
              this.captureCanvas.height = this.video.videoHeight;

              this.updateStatus(
                "📍 Position your face in the oval",
                "misaligned"
              );
              document.getElementById("faceGuide").classList.add("detecting");

              setTimeout(() => {
                this.startDetection();
              }, 1000);
            };
          } catch (err) {
            console.error("Camera error:", err);
            this.showError(
              "Camera access denied. Please allow camera permissions and try again."
            );
          }
        }

        startDetection() {
          if (this.detectionInterval) {
            clearInterval(this.detectionInterval);
          }

          this.detectionInterval = setInterval(() => {
            if (!this.isCapturing && this.video.readyState === 4) {
              this.checkFaceAlignment();
            }
          }, 100);
        }

        checkFaceAlignment() {
          this.captureCtx.drawImage(
            this.video,
            0,
            0,
            this.captureCanvas.width,
            this.captureCanvas.height
          );
          const imageData = this.captureCtx.getImageData(
            0,
            0,
            this.captureCanvas.width,
            this.captureCanvas.height
          );
          const data = imageData.data;
          const result = this.analyzeFrame(
            data,
            this.captureCanvas.width,
            this.captureCanvas.height
          );

          if (result.isAligned && !result.hasMotion) {
            this.alignmentCounter++;

            if (this.alignmentCounter === 5) {
              this.updateStatus("✅ Good! Keep your position...", "aligned");
              document.getElementById("faceGuide").classList.add("aligned");
              document
                .getElementById("faceGuide")
                .classList.remove("detecting");
            }

            if (this.alignmentCounter >= this.requiredAlignmentFrames) {
              this.beginCapture();
            } else if (this.alignmentCounter > 5) {
              const progress = Math.floor(
                (this.alignmentCounter / this.requiredAlignmentFrames) * 100
              );
              this.updateStatus(
                `✅ Perfect! Detecting... ${progress}%`,
                "aligned"
              );
            }
          } else {
            if (this.alignmentCounter > 0) {
              this.alignmentCounter = 0;
              document.getElementById("faceGuide").classList.remove("aligned");
              document.getElementById("faceGuide").classList.add("detecting");
            }

            if (result.hasMotion) {
              this.updateStatus(
                "⚠️ Too much movement - Stay still",
                "misaligned"
              );
            } else {
              this.updateStatus(result.message, "misaligned");
            }
          }

          this.previousFrame = data.slice();
        }

        analyzeFrame(data, width, height) {
          const centerX = width / 2;
          const centerY = height / 2;
          const ovalWidth = 200;
          const ovalHeight = 260;

          let brightnessSum = 0;
          let pixelCount = 0;
          let centerWeightSum = 0;

          let motionLevel = 0;
          if (this.previousFrame) {
            for (let i = 0; i < data.length; i += 4) {
              const diff =
                Math.abs(data[i] - this.previousFrame[i]) +
                Math.abs(data[i + 1] - this.previousFrame[i + 1]) +
                Math.abs(data[i + 2] - this.previousFrame[i + 2]);
              motionLevel += diff;
            }
            motionLevel = motionLevel / (width * height);
          }

          for (
            let y = centerY - ovalHeight / 2;
            y < centerY + ovalHeight / 2;
            y += 5
          ) {
            for (
              let x = centerX - ovalWidth / 2;
              x < centerX + ovalWidth / 2;
              x += 5
            ) {
              const dx = (x - centerX) / (ovalWidth / 2);
              const dy = (y - centerY) / (ovalHeight / 2);
              if (dx * dx + dy * dy <= 1) {
                const idx = (Math.floor(y) * width + Math.floor(x)) * 4;
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];
                const brightness = (r + g + b) / 3;
                brightnessSum += brightness;
                const distFromCenter = Math.sqrt(dx * dx + dy * dy);
                centerWeightSum += (1 - distFromCenter) * brightness;
                pixelCount++;
              }
            }
          }

          if (pixelCount === 0) {
            return {
              isAligned: false,
              message: "❌ No face detected in guide",
              hasMotion: false,
            };
          }

          const avgBrightness = brightnessSum / pixelCount;
          const centerWeight = centerWeightSum / pixelCount;

          if (motionLevel > this.motionThreshold) {
            return {
              isAligned: false,
              message: "⚠️ Too much movement detected",
              hasMotion: true,
            };
          }

          if (avgBrightness < 50) {
            return {
              isAligned: false,
              message: "💡 Too dark - improve lighting",
              hasMotion: false,
            };
          }

          if (avgBrightness > 200) {
            return {
              isAligned: false,
              message: "☀️ Too bright - reduce lighting",
              hasMotion: false,
            };
          }

          if (centerWeight < 40) {
            return {
              isAligned: false,
              message: "🎯 Center your face in the oval",
              hasMotion: false,
            };
          }

          return {
            isAligned: true,
            message: "✅ Perfect alignment!",
            hasMotion: false,
          };
        }

        beginCapture() {
          if (this.isCapturing) return;

          this.isCapturing = true;
          this.alignmentCounter = 0;

          if (this.detectionInterval) {
            clearInterval(this.detectionInterval);
          }

          let countdown = 3;
          const countdownElement = document.getElementById("countdown");

          this.updateStatus("📸 Get ready for capture!", "capturing");

          const countdownInterval = setInterval(() => {
            if (countdown > 0) {
              countdownElement.style.display = "block";
              countdownElement.textContent = countdown;
              countdownElement.style.animation = "none";
              setTimeout(() => {
                countdownElement.style.animation = "countdownPulse 1s ease";
              }, 10);
              countdown--;
            } else {
              clearInterval(countdownInterval);
              countdownElement.style.display = "none";
              this.startCaptureWithProgress();
            }
          }, 1000);
        }

        startCaptureWithProgress() {
          const progressContainer =
            document.getElementById("progressContainer");
          const progressFill = document.getElementById("progressFill");
          const progressText = document.getElementById("progressText");

          progressContainer.classList.add("active");
          this.updateStatus(
            "📸 Capturing... Hold perfectly still!",
            "capturing"
          );

          let progress = 0;
          const increment = 100 / (this.captureDelayMs / 50);

          const progressInterval = setInterval(() => {
            progress += increment;

            if (progress >= 100) {
              progress = 100;
              clearInterval(progressInterval);

              setTimeout(() => {
                this.captureImage();
                progressContainer.classList.remove("active");
                progressFill.style.width = "0%";
              }, 200);
            }

            progressFill.style.width = progress + "%";

            if (progress < 30) {
              progressText.textContent = "Analyzing face position...";
            } else if (progress < 60) {
              progressText.textContent = "Detecting facial features...";
            } else if (progress < 90) {
              progressText.textContent = "Finalizing capture...";
            } else {
              progressText.textContent = "Almost done!";
            }
          }, 50);
        }

        async captureImage() {
          this.captureCtx.drawImage(
            this.video,
            0,
            0,
            this.captureCanvas.width,
            this.captureCanvas.height
          );
          this.capturedPhoto = this.captureCanvas.toDataURL("image/png");

          await this.initializeFaceMesh();

          this.isCapturing = false;
          document
            .getElementById("faceGuide")
            .classList.remove("aligned", "detecting");
        }

        async initializeFaceMesh() {
          this.updateStatus("🔍 Detecting facial features...", "capturing");

          this.faceMesh = new FaceMesh({
            locateFile: (file) =>
              `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
          });

          this.faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7,
          });

          this.faceMesh.onResults((results) =>
            this.processFaceMeshResults(results)
          );

          const img = new Image();
          img.onload = async () => {
            await this.faceMesh.send({ image: img });
          };
          img.src = this.capturedPhoto;
        }

        processFaceMeshResults(results) {
          if (
            results.multiFaceLandmarks &&
            results.multiFaceLandmarks.length > 0
          ) {
            this.landmarks = results.multiFaceLandmarks[0];

            this.calculatePreciseMeasurements();

            if (this.stream) {
              this.stream.getTracks().forEach((track) => track.stop());
            }

            this.showTryOnStep();
          } else {
            this.showError(
              "Could not detect facial features. Please retake the photo."
            );
            setTimeout(() => this.retake(), 2000);
          }
        }

        calculatePreciseMeasurements() {
          if (!this.landmarks) return;

          const img = new Image();
          img.onload = () => {
            const imgWidth = img.width;
            const imgHeight = img.height;

            // CORRECT METHOD: Calculate eye centers from multiple landmarks
            // Left eye center from outer, inner, top, bottom points
            const leftEyeOuter = this.landmarks[33];
            const leftEyeInner = this.landmarks[133];
            const leftEyeTop = this.landmarks[159];
            const leftEyeBottom = this.landmarks[145];

            const leftEyeCenter = {
              x:
                (leftEyeOuter.x +
                  leftEyeInner.x +
                  leftEyeTop.x +
                  leftEyeBottom.x) /
                4,
              y:
                (leftEyeOuter.y +
                  leftEyeInner.y +
                  leftEyeTop.y +
                  leftEyeBottom.y) /
                4,
            };

            // Right eye center from outer, inner, top, bottom points
            const rightEyeOuter = this.landmarks[263];
            const rightEyeInner = this.landmarks[362];
            const rightEyeTop = this.landmarks[386];
            const rightEyeBottom = this.landmarks[374];

            const rightEyeCenter = {
              x:
                (rightEyeOuter.x +
                  rightEyeInner.x +
                  rightEyeTop.x +
                  rightEyeBottom.x) /
                4,
              y:
                (rightEyeOuter.y +
                  rightEyeInner.y +
                  rightEyeTop.y +
                  rightEyeBottom.y) /
                4,
            };

            const noseCenter = this.landmarks[1];
            const leftCheek = this.landmarks[234];
            const rightCheek = this.landmarks[454];
            const foreheadTop = this.landmarks[10];
            const chinBottom = this.landmarks[152];

            // Convert to pixel coordinates
            const xL = leftEyeCenter.x * imgWidth;
            const yL = leftEyeCenter.y * imgHeight;
            const xR = rightEyeCenter.x * imgWidth;
            const yR = rightEyeCenter.y * imgHeight;
            const xN = noseCenter.x * imgWidth;
            const yN = noseCenter.y * imgHeight;

            const xLeftCheek = leftCheek.x * imgWidth;
            const xRightCheek = rightCheek.x * imgWidth;
            const yForehead = foreheadTop.y * imgHeight;
            const yChin = chinBottom.y * imgHeight;

            // Calculate PD measurements in pixels
            const pdTotalPx = Math.abs(xR - xL);
            const centerX = (xL + xR) / 2;
            const pdLeftPx = Math.abs(centerX - xL);
            const pdRightPx = Math.abs(xR - centerX);
            const leftNosePx = Math.abs(xN - xL);
            const rightNosePx = Math.abs(xR - xN);
            const noseTotalPx = leftNosePx + rightNosePx;

            const faceWidthPx = Math.abs(xRightCheek - xLeftCheek);
            const faceHeightPx = Math.abs(yChin - yForehead);

            // IMPROVED CALIBRATION: Use face width as reference (more stable than frame width)
            const estimatedFaceWidthMM = 140; // Average adult face width
            const pixelsPerMM = faceWidthPx / estimatedFaceWidthMM;

            // Convert all measurements to millimeters
            this.measurements.pdTotal = pdTotalPx / pixelsPerMM;
            this.measurements.pdLeft = pdLeftPx / pixelsPerMM;
            this.measurements.pdRight = pdRightPx / pixelsPerMM;
            this.measurements.leftNose = leftNosePx / pixelsPerMM;
            this.measurements.rightNose = rightNosePx / pixelsPerMM;
            this.measurements.noseTotal = noseTotalPx / pixelsPerMM;
            this.measurements.faceWidth = faceWidthPx / pixelsPerMM;
            this.measurements.faceHeight = faceHeightPx / pixelsPerMM;
            this.measurements.pixelsPerMM = pixelsPerMM;

            const eyeCenterY = (yL + yR) / 2;
            const selectedFrame = this.frames[this.selectedFrameIndex];
            const frameImg = this.frameImages[selectedFrame.id];

            if (frameImg) {
              const actualFrameHeightMM =
                selectedFrame.heightMM * (this.frameAdjustments.size / 100);
              const frameHeightPx = actualFrameHeightMM * pixelsPerMM;
              const frameBottomY =
                eyeCenterY + frameHeightPx / 2 + this.frameAdjustments.vertical;
              const fittingHeightPx = Math.abs(frameBottomY - eyeCenterY);
              this.measurements.fittingHeight = fittingHeightPx / pixelsPerMM;
            }

            this.measurements.faceRatio =
              this.measurements.faceWidth / this.measurements.faceHeight;
            const faceShape = this.classifyFaceShape(
              this.measurements.faceRatio
            );
            this.displayMeasurements(faceShape);
          };
          img.src = this.capturedPhoto;
        }

        classifyFaceShape(ratio) {
          if (ratio >= 0.85 && ratio <= 1.0) {
            return "Square";
          } else if (ratio >= 0.75 && ratio < 0.85) {
            return "Round";
          } else if (ratio >= 0.65 && ratio < 0.75) {
            return "Oval";
          } else if (ratio < 0.65) {
            return "Long/Oblong";
          } else {
            return "Heart/Diamond";
          }
        }

        displayMeasurements(faceShape) {
          document.getElementById("pdTotalMeasurement").textContent =
            this.measurements.pdTotal.toFixed(1) + " mm";
          document.getElementById("pdLeftMeasurement").textContent =
            this.measurements.pdLeft.toFixed(1) + " mm";
          document.getElementById("pdRightMeasurement").textContent =
            this.measurements.pdRight.toFixed(1) + " mm";
          document.getElementById("leftNoseMeasurement").textContent =
            this.measurements.leftNose.toFixed(1) + " mm";
          document.getElementById("rightNoseMeasurement").textContent =
            this.measurements.rightNose.toFixed(1) + " mm";
          document.getElementById("totalNoseMeasurement").textContent =
            this.measurements.noseTotal.toFixed(1) + " mm";
          document.getElementById("fittingHeightMeasurement").textContent =
            this.measurements.fittingHeight.toFixed(1) + " mm";
          document.getElementById("faceWidthMeasurement").textContent =
            this.measurements.faceWidth.toFixed(1) + " mm";
          document.getElementById("faceHeightMeasurement").textContent =
            this.measurements.faceHeight.toFixed(1) + " mm";
          document.getElementById("faceRatioMeasurement").textContent =
            this.measurements.faceRatio.toFixed(2);
          document.getElementById("faceShapeMeasurement").textContent =
            faceShape;
        }

        updateDynamicMeasurements() {
          if (!this.landmarks) return;

          const img = new Image();
          img.onload = () => {
            const imgWidth = img.width;
            const imgHeight = img.height;

            const leftEyeOuter = this.landmarks[33];
            const leftEyeInner = this.landmarks[133];
            const leftEyeTop = this.landmarks[159];
            const leftEyeBottom = this.landmarks[145];

            const leftEyeCenter = {
              x:
                (leftEyeOuter.x +
                  leftEyeInner.x +
                  leftEyeTop.x +
                  leftEyeBottom.x) /
                4,
              y:
                (leftEyeOuter.y +
                  leftEyeInner.y +
                  leftEyeTop.y +
                  leftEyeBottom.y) /
                4,
            };

            const rightEyeOuter = this.landmarks[263];
            const rightEyeInner = this.landmarks[362];
            const rightEyeTop = this.landmarks[386];
            const rightEyeBottom = this.landmarks[374];

            const rightEyeCenter = {
              x:
                (rightEyeOuter.x +
                  rightEyeInner.x +
                  rightEyeTop.x +
                  rightEyeBottom.x) /
                4,
              y:
                (rightEyeOuter.y +
                  rightEyeInner.y +
                  rightEyeTop.y +
                  rightEyeBottom.y) /
                4,
            };

            const leftY = leftEyeCenter.y * imgHeight;
            const rightY = rightEyeCenter.y * imgHeight;
            const eyeCenterY = (leftY + rightY) / 2;

            const selectedFrame = this.frames[this.selectedFrameIndex];
            const frameImg = this.frameImages[selectedFrame.id];

            if (frameImg && this.measurements.pixelsPerMM) {
              const pixelsPerMM = this.measurements.pixelsPerMM;
              const actualFrameHeightMM =
                selectedFrame.heightMM * (this.frameAdjustments.size / 100);
              const frameHeightPx = actualFrameHeightMM * pixelsPerMM;
              const frameBottomY =
                eyeCenterY + frameHeightPx / 2 + this.frameAdjustments.vertical;
              const fittingHeightPx = Math.abs(frameBottomY - eyeCenterY);

              this.measurements.fittingHeight = fittingHeightPx / pixelsPerMM;

              document.getElementById("fittingHeightMeasurement").textContent =
                this.measurements.fittingHeight.toFixed(1) + " mm";
            }
          };
          img.src = this.capturedPhoto;
        }

        recalculateAllMeasurements() {
          if (!this.landmarks) return;

          const img = new Image();
          img.onload = () => {
            const imgWidth = img.width;
            const imgHeight = img.height;

            // CORRECT METHOD: Calculate eye centers from multiple landmarks
            const leftEyeOuter = this.landmarks[33];
            const leftEyeInner = this.landmarks[133];
            const leftEyeTop = this.landmarks[159];
            const leftEyeBottom = this.landmarks[145];

            const leftEyeCenter = {
              x:
                (leftEyeOuter.x +
                  leftEyeInner.x +
                  leftEyeTop.x +
                  leftEyeBottom.x) /
                4,
              y:
                (leftEyeOuter.y +
                  leftEyeInner.y +
                  leftEyeTop.y +
                  leftEyeBottom.y) /
                4,
            };

            const rightEyeOuter = this.landmarks[263];
            const rightEyeInner = this.landmarks[362];
            const rightEyeTop = this.landmarks[386];
            const rightEyeBottom = this.landmarks[374];

            const rightEyeCenter = {
              x:
                (rightEyeOuter.x +
                  rightEyeInner.x +
                  rightEyeTop.x +
                  rightEyeBottom.x) /
                4,
              y:
                (rightEyeOuter.y +
                  rightEyeInner.y +
                  rightEyeTop.y +
                  rightEyeBottom.y) /
                4,
            };

            const noseCenter = this.landmarks[1];
            const leftCheek = this.landmarks[234];
            const rightCheek = this.landmarks[454];
            const foreheadTop = this.landmarks[10];
            const chinBottom = this.landmarks[152];

            const xL = leftEyeCenter.x * imgWidth;
            const yL = leftEyeCenter.y * imgHeight;
            const xR = rightEyeCenter.x * imgWidth;
            const yR = rightEyeCenter.y * imgHeight;
            const xN = noseCenter.x * imgWidth;
            const yN = noseCenter.y * imgHeight;
            const xLeftCheek = leftCheek.x * imgWidth;
            const xRightCheek = rightCheek.x * imgWidth;
            const yForehead = foreheadTop.y * imgHeight;
            const yChin = chinBottom.y * imgHeight;

            const pdTotalPx = Math.abs(xR - xL);
            const centerX = (xL + xR) / 2;
            const pdLeftPx = Math.abs(centerX - xL);
            const pdRightPx = Math.abs(xR - centerX);
            const leftNosePx = Math.abs(xN - xL);
            const rightNosePx = Math.abs(xR - xN);
            const noseTotalPx = leftNosePx + rightNosePx;
            const faceWidthPx = Math.abs(xRightCheek - xLeftCheek);
            const faceHeightPx = Math.abs(yChin - yForehead);

            // Use face width for calibration (more stable)
            const estimatedFaceWidthMM = 140;
            const pixelsPerMM = faceWidthPx / estimatedFaceWidthMM;

            this.measurements.pdTotal = pdTotalPx / pixelsPerMM;
            this.measurements.pdLeft = pdLeftPx / pixelsPerMM;
            this.measurements.pdRight = pdRightPx / pixelsPerMM;
            this.measurements.leftNose = leftNosePx / pixelsPerMM;
            this.measurements.rightNose = rightNosePx / pixelsPerMM;
            this.measurements.noseTotal = noseTotalPx / pixelsPerMM;
            this.measurements.faceWidth = faceWidthPx / pixelsPerMM;
            this.measurements.faceHeight = faceHeightPx / pixelsPerMM;
            this.measurements.pixelsPerMM = pixelsPerMM;

            const eyeCenterY = (yL + yR) / 2;
            const selectedFrame = this.frames[this.selectedFrameIndex];
            const frameImg = this.frameImages[selectedFrame.id];

            if (frameImg) {
              const actualFrameHeightMM =
                selectedFrame.heightMM * (this.frameAdjustments.size / 100);
              const frameHeightPx = actualFrameHeightMM * pixelsPerMM;
              const frameBottomY =
                eyeCenterY + frameHeightPx / 2 + this.frameAdjustments.vertical;
              const fittingHeightPx = Math.abs(frameBottomY - eyeCenterY);
              this.measurements.fittingHeight = fittingHeightPx / pixelsPerMM;
            }

            this.measurements.faceRatio =
              this.measurements.faceWidth / this.measurements.faceHeight;
            const faceShape = this.classifyFaceShape(
              this.measurements.faceRatio
            );
            this.displayMeasurements(faceShape);
          };
          img.src = this.capturedPhoto;
        }

        showTryOnStep() {
          document.getElementById("step1").classList.remove("active");
          document.getElementById("step2").classList.add("active");

          this.renderFrameSelector();

          const img = new Image();
          img.onload = () => {
            this.overlayCanvas.width = img.width;
            this.overlayCanvas.height = img.height;
            this.overlayCanvas.style.display = "block";
            this.updateOverlay();
          };
          img.src = this.capturedPhoto;
        }

        renderFrameSelector() {
          const selector = document.getElementById("frameSelector");
          selector.innerHTML = "";

          this.frames.forEach((frame, idx) => {
            const div = document.createElement("div");
            div.className = "frame-option" + (idx === 0 ? " selected" : "");

            const img = this.frameImages[frame.id];
            if (img) {
              div.innerHTML = `
                <div class="frame-preview">
                  <img src="${frame.src}" style="max-width: 100%; max-height: 100%; object-fit: contain;" />
                </div>
                <div>${frame.name}</div>
              `;
            } else {
              div.innerHTML = `
                <div class="frame-preview">Loading...</div>
                <div>${frame.name}</div>
              `;
            }

            div.addEventListener("click", () => {
              document
                .querySelectorAll(".frame-option")
                .forEach((o) => o.classList.remove("selected"));
              div.classList.add("selected");
              this.selectedFrameIndex = idx;
              this.updateOverlay();
              this.recalculateAllMeasurements();
            });
            selector.appendChild(div);
          });
        }

        updateOverlay() {
          if (!this.capturedPhoto || !this.landmarks) return;

          const ctx = this.overlayCtx;
          const img = new Image();

          img.onload = () => {
            ctx.clearRect(
              0,
              0,
              this.overlayCanvas.width,
              this.overlayCanvas.height
            );
            ctx.drawImage(
              img,
              0,
              0,
              this.overlayCanvas.width,
              this.overlayCanvas.height
            );

            const selectedFrame = this.frames[this.selectedFrameIndex];
            const frameImg = this.frameImages[selectedFrame.id];

            if (!frameImg) return;

            // CORRECT METHOD: Use proper eye center calculation
            const leftEyeOuter = this.landmarks[33];
            const leftEyeInner = this.landmarks[133];
            const leftEyeTop = this.landmarks[159];
            const leftEyeBottom = this.landmarks[145];

            const leftEyeCenter = {
              x:
                (leftEyeOuter.x +
                  leftEyeInner.x +
                  leftEyeTop.x +
                  leftEyeBottom.x) /
                4,
              y:
                (leftEyeOuter.y +
                  leftEyeInner.y +
                  leftEyeTop.y +
                  leftEyeBottom.y) /
                4,
            };

            const rightEyeOuter = this.landmarks[263];
            const rightEyeInner = this.landmarks[362];
            const rightEyeTop = this.landmarks[386];
            const rightEyeBottom = this.landmarks[374];

            const rightEyeCenter = {
              x:
                (rightEyeOuter.x +
                  rightEyeInner.x +
                  rightEyeTop.x +
                  rightEyeBottom.x) /
                4,
              y:
                (rightEyeOuter.y +
                  rightEyeInner.y +
                  rightEyeTop.y +
                  rightEyeBottom.y) /
                4,
            };

            const leftX = leftEyeCenter.x * img.width;
            const leftY = leftEyeCenter.y * img.height;
            const rightX = rightEyeCenter.x * img.width;
            const rightY = rightEyeCenter.y * img.height;

            const eyeDistance = Math.abs(rightX - leftX);
            const eyeCenterX = (leftX + rightX) / 2;
            const eyeCenterY = (leftY + rightY) / 2;

            const frameWidth =
              eyeDistance * 3 * (this.frameAdjustments.size / 100);
            const frameHeight = (frameImg.height / frameImg.width) * frameWidth;

            const frameX = eyeCenterX - frameWidth / 2;
            const frameY =
              eyeCenterY - frameHeight / 2 + this.frameAdjustments.vertical;

            ctx.save();
            ctx.translate(
              eyeCenterX,
              eyeCenterY + this.frameAdjustments.vertical
            );
            ctx.rotate((this.frameAdjustments.rotation * Math.PI) / 180);
            ctx.translate(
              -eyeCenterX,
              -(eyeCenterY + this.frameAdjustments.vertical)
            );

            ctx.drawImage(frameImg, frameX, frameY, frameWidth, frameHeight);

            ctx.restore();
          };

          img.src = this.capturedPhoto;
        }

        resetAdjustments() {
          this.frameAdjustments = { vertical: 0, size: 100, rotation: 0 };
          document.getElementById("verticalSlider").value = 0;
          document.getElementById("sizeSlider").value = 100;
          document.getElementById("rotationSlider").value = 0;
          document.getElementById("verticalValue").textContent = "0";
          document.getElementById("sizeValue").textContent = "100%";
          document.getElementById("rotationValue").textContent = "0°";
          this.updateOverlay();
          this.recalculateAllMeasurements();
        }

        downloadImage() {
          const link = document.createElement("a");
          link.download = "virtual_tryon_" + Date.now() + ".png";
          link.href = this.overlayCanvas.toDataURL("image/png");
          link.click();
        }

        retake() {
          this.capturedPhoto = null;
          this.landmarks = null;
          this.alignmentCounter = 0;
          this.isCapturing = false;
          this.frameAdjustments = { vertical: 0, size: 100, rotation: 0 };
          this.measurements = {
            pdTotal: 0,
            pdLeft: 0,
            pdRight: 0,
            leftNose: 0,
            rightNose: 0,
            noseTotal: 0,
            fittingHeight: 0,
            faceWidth: 0,
            faceHeight: 0,
            faceRatio: 0,
            pixelsPerMM: 0,
          };

          document.getElementById("step2").classList.remove("active");
          document.getElementById("step1").classList.add("active");
          document.getElementById("startBtn").style.display = "inline-block";
          document
            .getElementById("faceGuide")
            .classList.remove("aligned", "detecting");

          this.updateStatus("Click 'Start Camera' to begin", "misaligned");
        }

        updateStatus(message, className) {
          const status = document.getElementById("alignmentStatus");
          status.textContent = message;
          status.className = "alignment-status " + className;
        }

        showError(message) {
          const errorElement = document.getElementById("errorMessage");
          errorElement.textContent = message;
          errorElement.style.display = "block";
          setTimeout(() => {
            errorElement.style.display = "none";
          }, 5000);
        }
      }

      const app = new FaceCaptureApp();

      window.addEventListener("beforeunload", () => {
        if (app.stream) {
          app.stream.getTracks().forEach((track) => track.stop());
        }
        if (app.detectionInterval) {
          clearInterval(app.detectionInterval);
        }
      });
    </script>
  </body>
</html>
